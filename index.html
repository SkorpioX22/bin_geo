<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>bin_geo</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root {
  --bg:#000;
  --fg:#fff;
  --muted:#777;
}

* {
  box-sizing: border-box;
  font-family: "JetBrains Mono", monospace;
}

html, body {
  margin: 0;
  background: var(--bg);
  color: var(--fg);
  overflow: hidden;
}

/* ===== UI ===== */

.ui {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10;
  transition: opacity 0.35s ease, transform 0.35s ease;
}

.ui.hidden {
  opacity: 0;
  pointer-events: none;
}

.ui.reveal {
  opacity: 1;
  pointer-events: auto;
}

/* Hover trigger zone */
#uiHoverZone {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 28px;
  z-index: 9;
}

h1 {
  font-size: 1.1rem;
  letter-spacing: 0.25em;
  margin-bottom: 10px;
}

input {
  width: 420px;
  padding: 12px;
  background: transparent;
  border: 1px solid white;
  color: white;
  outline: none;
}

input::placeholder {
  color: var(--muted);
}

button {
  margin-top: 10px;
  margin-right: 8px;
  padding: 10px 16px;
  background: black;
  border: 1px solid white;
  color: white;
  cursor: pointer;
  transition: 0.25s;
}

button:hover {
  background: white;
  color: black;
}

canvas {
  position: absolute;
  inset: 0;
  cursor: grab;
}

canvas:active {
  cursor: grabbing;
}

/* ===== Screenshot toast ===== */

.toast {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translate(-50%, 20px);
  padding: 10px 18px;
  border: 1px solid white;
  background: black;
  color: white;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease, transform 0.4s ease;
}

.toast.show {
  opacity: 1;
  transform: translate(-50%, 0);
}
</style>
</head>

<body>

<!-- Hover reveal strip -->
<div id="uiHoverZone"></div>

<div class="ui" id="ui">
  <h1 id="title"></h1>
  <p>(turn binary strings into complex geometry)</p>

  <input id="binary" placeholder="each bit = one line. scroll and pan with mouse." />
  <br>

  <button id="reset">AUTO ZOOM</button>
  <button id="clear">CLEAR</button>
  <button id="toggleUI">HIDE UI</button>
  <button id="shot">SCREENSHOT</button>

  <br><br>
  <a href="https://github.com/SkorpioX22" target="_blank" style="color:white;text-decoration:underline">
    created by skorpiox22
  </a>
</div>

<div class="toast" id="toast">copied to clipboard</div>

<canvas id="c"></canvas>

<script>
/* ================== TITLE REVEAL ================== */

const titleText = "bin_geo";
const glyphs = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&";
const titleEl = document.getElementById("title");

let revealed = 0;
const totalDuration = 2500;
const interval = totalDuration / titleText.length;

function scrambleText() {
  let out = "";
  for (let i = 0; i < titleText.length; i++) {
    out += i < revealed
      ? titleText[i]
      : glyphs[Math.floor(Math.random() * glyphs.length)];
  }
  titleEl.textContent = out;
}

const revealTimer = setInterval(() => {
  revealed++;
  if (revealed > titleText.length) {
    clearInterval(revealTimer);
    titleEl.textContent = titleText;
  }
}, interval);

(function animateTitle() {
  scrambleText();
  if (revealed <= titleText.length) requestAnimationFrame(animateTitle);
})();

/* ================== CANVAS ================== */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w, h;
function resize() {
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* ================== CONFIG ================== */

const EASE_POINTS = 0.025;
const EASE_VIEW   = 0.02;

const BASE_STEP = 40;
const TURN_0 = -Math.PI / 2.2;
const TURN_1 =  Math.PI / 3;

/* ================== VIEW STATE ================== */

let zoom = 1, panX = 0, panY = 0;
let targetZoom = 1, targetPanX = 0, targetPanY = 0;
let autoFit = true;

/* ================== SHAPE ================== */

let currentPoints = [];
let targetPoints = [];

function generatePolyline(binary) {
  let x = 0, y = 0;
  let angle = -Math.PI / 2;
  const pts = [{ x, y }];

  for (const bit of binary) {
    angle += bit === "1" ? TURN_1 : TURN_0;
    x += Math.cos(angle) * BASE_STEP;
    y += Math.sin(angle) * BASE_STEP;
    pts.push({ x, y });
  }
  return pts;
}

function computeAutoFitTargets(pts) {
  if (pts.length < 2) return;

  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  for (const p of pts) {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }

  const shapeW = maxX - minX;
  const shapeH = maxY - minY;

  targetZoom = Math.min((w * 0.75) / shapeW, (h * 0.75) / shapeH);
  targetPanX = w / 2 - ((minX + maxX) / 2) * targetZoom;
  targetPanY = h / 2 - ((minY + maxY) / 2) * targetZoom;
}

/* ================== INPUT ================== */

const input = document.getElementById("binary");
input.addEventListener("input", () => {
  input.value = input.value.replace(/[^01]/g, "");
  targetPoints = generatePolyline(input.value);
  if (autoFit) computeAutoFitTargets(targetPoints);
  syncPointCounts();
});

document.getElementById("clear").onclick = () => {
  input.value = "";
  targetPoints = [];
  currentPoints = [];
};

document.getElementById("reset").onclick = () => {
  autoFit = true;
  computeAutoFitTargets(targetPoints);
};

/* ================== UI HIDE / HOVER ================== */

const ui = document.getElementById("ui");
const hoverZone = document.getElementById("uiHoverZone");
const toggleBtn = document.getElementById("toggleUI");
let uiHidden = false;

toggleBtn.onclick = () => {
  uiHidden = !uiHidden;
  ui.classList.toggle("hidden", uiHidden);
  toggleBtn.textContent = uiHidden ? "SHOW UI" : "HIDE UI";
};

hoverZone.addEventListener("mouseenter", () => {
  if (uiHidden) ui.classList.add("reveal");
});

ui.addEventListener("mouseleave", () => {
  if (uiHidden) ui.classList.remove("reveal");
});

/* ================== SCREENSHOT ================== */

const toast = document.getElementById("toast");

document.getElementById("shot").onclick = async () => {
  ui.classList.add("hidden");

  requestAnimationFrame(() => {
    const off = document.createElement("canvas");
    off.width = canvas.width;
    off.height = canvas.height;
    const offCtx = off.getContext("2d");

    offCtx.fillStyle = "#000";
    offCtx.fillRect(0, 0, off.width, off.height);
    offCtx.drawImage(canvas, 0, 0);

    off.toBlob(async blob => {
      await navigator.clipboard.write([
        new ClipboardItem({ "image/png": blob })
      ]);

      if (!uiHidden) ui.classList.remove("hidden");

      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 1600);
    });
  });
};

/* ================== MORPH ================== */

function syncPointCounts() {
  while (currentPoints.length < targetPoints.length)
    currentPoints.push({ ...targetPoints[currentPoints.length - 1] });
  while (currentPoints.length > targetPoints.length)
    currentPoints.pop();
}

const lerp = (a, b, t) => a + (b - a) * t;

/* ================== PAN & ZOOM ================== */

let dragging = false;
let lastX = 0, lastY = 0;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  autoFit = false;
  lastX = e.clientX;
  lastY = e.clientY;
});

addEventListener("mouseup", () => dragging = false);

addEventListener("mousemove", e => {
  if (!dragging) return;
  panX += e.clientX - lastX;
  panY += e.clientY - lastY;
  targetPanX = panX;
  targetPanY = panY;
  lastX = e.clientX;
  lastY = e.clientY;
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  autoFit = false;

  const scale = Math.exp(-e.deltaY * 0.001);
  const mx = e.clientX;
  const my = e.clientY;

  panX = mx - (mx - panX) * scale;
  panY = my - (my - panY) * scale;
  zoom *= scale;

  targetZoom = zoom;
  targetPanX = panX;
  targetPanY = panY;
}, { passive: false });

/* ================== DRAW ================== */

function animate() {
  ctx.clearRect(0, 0, w, h);

  zoom = lerp(zoom, targetZoom, EASE_VIEW);
  panX = lerp(panX, targetPanX, EASE_VIEW);
  panY = lerp(panY, targetPanY, EASE_VIEW);

  if (targetPoints.length > 1) {
    for (let i = 0; i < targetPoints.length; i++) {
      currentPoints[i].x = lerp(currentPoints[i].x, targetPoints[i].x, EASE_POINTS);
      currentPoints[i].y = lerp(currentPoints[i].y, targetPoints[i].y, EASE_POINTS);
    }

    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    ctx.beginPath();
    ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
    for (let i = 1; i < currentPoints.length; i++)
      ctx.lineTo(currentPoints[i].x, currentPoints[i].y);

    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1.6 / zoom;
    ctx.stroke();

    ctx.restore();
  }

  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
